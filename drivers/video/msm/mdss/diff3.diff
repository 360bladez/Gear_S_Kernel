1c1
< /* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
---
> /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
25a26
> #include <linux/sort.h>
26a28
> #include <soc/qcom/scm.h>
28,31c30,32
< #include <mach/iommu_domains.h>
< #include <mach/event_timer.h>
< #include <mach/msm_bus.h>
< #include <mach/scm.h>
---
> #include <linux/msm_iommu_domains.h>
> #include <soc/qcom/event_timer.h>
> #include <linux/msm-bus.h>
37a39,40
> #include "splash.h"
> 
42a46,48
> #define IS_RIGHT_MIXER_OV(flags, dst_x, left_lm_w)	\
> 	((flags & MDSS_MDP_RIGHT_MIXER) || (dst_x >= left_lm_w))
> 
46,64d51
< #ifdef	__MDSS_DEBUG__
< 
< #define ID_PRINTK(mdss_id, fmt, args...)   if(mfd->index == mdss_id) printk(fmt, ##args);
< #else
< 
< #define ID_PRINTK(mdss_id, fmt, args...)
< #endif
< 
< enum mdss_id_state {
< 	ID_LCD = 0,
< 	ID_HDMI = 1
< };
< int get_lcd_attached(void);
< 
< 
< #ifdef CONFIG_FB_MSM_CAMERA_CSC
< u8 pre_csc_update = 0xFF;
< #endif
< 
66a54,55
> #define INVALID_PIPE_INDEX 0xFFFF
> 
71,77d59
< #if defined (CONFIG_FB_MSM_MDSS_DBG_SEQ_TICK)
< static struct mdss_tick_debug mdss_dbg_tick;
< #endif
< struct list_head *pipes_used_dbg;
< 
< DEFINE_MUTEX(free_list_purge_mutex);
< 
83,86c65,82
< #if defined(CONFIG_FB_MSM_MDSS_S6E8AA0A_HD_PANEL)
< extern int err_fg_working;
< extern int lcd_connected_status;
< #endif
---
> static void __overlay_kickoff_requeue(struct msm_fb_data_type *mfd);
> 
> static inline bool is_ov_right_blend(struct mdp_rect *left_blend,
> 	struct mdp_rect *right_blend, u32 left_lm_w)
> {
> 	return (((left_blend->x + left_blend->w) == right_blend->x)	&&
> 		((left_blend->x + left_blend->w) != left_lm_w)		&&
> 		(left_blend->x != right_blend->x)			&&
> 		(left_blend->y == right_blend->y)			&&
> 		(left_blend->h == right_blend->h));
> }
> 
> static inline u32 left_lm_w_from_mfd(struct msm_fb_data_type *mfd)
> {
> 	struct mdss_mdp_ctl *ctl = mfd_to_ctl(mfd);
> 	return (ctl && ctl->mixer_left) ? ctl->mixer_left->width : 0;
> }
> 
93d88
< 	pr_debug("sd_ctrl %u\n", enable);
124a120,189
> static int mdss_mdp_ov_xres_check(struct msm_fb_data_type *mfd,
> 	struct mdp_overlay *req)
> {
> 	u32 xres = 0;
> 	u32 left_lm_w = left_lm_w_from_mfd(mfd);
> 	struct mdss_data_type *mdata = mfd_to_mdata(mfd);
> 	struct mdss_mdp_ctl *ctl = mfd_to_ctl(mfd);
> 
> 	if (IS_RIGHT_MIXER_OV(req->flags, req->dst_rect.x, left_lm_w)) {
> 		if (mdata->has_src_split) {
> 			xres = left_lm_w;
> 
> 			if (req->flags & MDSS_MDP_RIGHT_MIXER) {
> 				pr_warn("invalid use of RIGHT_MIXER flag.\n");
> 				/*
> 				 * if chip-set is capable of source split then
> 				 * all layers which are only on right LM should
> 				 * have their x offset relative to left LM's
> 				 * left-top or in other words relative to
> 				 * panel width.
> 				 * By modifying dst_x below, we are assuming
> 				 * that client is running in legacy mode
> 				 * chipset capable of source split.
> 				 */
> 				if (req->dst_rect.x < left_lm_w)
> 					req->dst_rect.x += left_lm_w;
> 
> 				req->flags &= ~MDSS_MDP_RIGHT_MIXER;
> 			}
> 		} else if (req->dst_rect.x >= left_lm_w) {
> 			/*
> 			 * this is a step towards removing a reliance on
> 			 * MDSS_MDP_RIGHT_MIXER flags. With the new src split
> 			 * code, some clients of non-src-split chipsets have
> 			 * stopped sending MDSS_MDP_RIGHT_MIXER flag and
> 			 * modified their xres relative to full panel
> 			 * dimensions. In such cases, we need to deduct left
> 			 * layer mixer width before we programm this HW.
> 			 */
> 			req->dst_rect.x -= left_lm_w;
> 			req->flags |= MDSS_MDP_RIGHT_MIXER;
> 		}
> 
> 		if (ctl->mixer_right) {
> 			xres += ctl->mixer_right->width;
> 		} else {
> 			pr_err("ov cannot be placed on right mixer\n");
> 			return -EPERM;
> 		}
> 	} else {
> 		if (ctl->mixer_left) {
> 			xres = ctl->mixer_left->width;
> 		} else {
> 			pr_err("ov cannot be placed on left mixer\n");
> 			return -EPERM;
> 		}
> 
> 		if (mdata->has_src_split && ctl->mixer_right)
> 			xres += ctl->mixer_right->width;
> 	}
> 
> 	if (CHECK_BOUNDS(req->dst_rect.x, req->dst_rect.w, xres)) {
> 		pr_err("dst_xres is invalid. dst_x:%d, dst_w:%d, xres:%d\n",
> 			req->dst_rect.x, req->dst_rect.w, xres);
> 		return -EOVERFLOW;
> 	}
> 
> 	return 0;
> }
> 
129c194
< 	u32 xres, yres;
---
> 	u32 yres;
135d199
< 	xres = mfd->fbi->var.xres;
183a248,253
> 		} else if (req->flags & MDP_BWC_EN) {
> 			pr_err("Decimation can't be enabled with BWC\n");
> 			return -EINVAL;
> 		} else if (fmt->tile) {
> 			pr_err("Decimation can't be enabled with MacroTile format\n");
> 			return -EINVAL;
190,194c260,262
< 		if ((CHECK_BOUNDS(req->dst_rect.x, req->dst_rect.w, xres) ||
< 		     CHECK_BOUNDS(req->dst_rect.y, req->dst_rect.h, yres))) {
< 			pr_err("invalid destination rect=%d,%d,%d,%d\n",
< 			       req->dst_rect.x, req->dst_rect.y,
< 			       req->dst_rect.w, req->dst_rect.h);
---
> 		if (CHECK_BOUNDS(req->dst_rect.y, req->dst_rect.h, yres)) {
> 			pr_err("invalid vertical destination: y=%d, h=%d\n",
> 				req->dst_rect.y, req->dst_rect.h);
285c353
< 	struct mdss_data_type *mdata = pipe->mixer->ctl->mdata;
---
> 	struct mdss_data_type *mdata = pipe->mixer_left->ctl->mdata;
290c358
< 		rc = mdss_mdp_perf_calc_pipe(pipe, &perf);
---
> 		rc = mdss_mdp_perf_calc_pipe(pipe, &perf, NULL, true);
292c360,361
< 		if (!rc && (perf.mdp_clk_rate <= mdata->max_mdp_clk_rate))
---
> 		if (!rc && (perf.mdp_clk_rate <= mdata->max_mdp_clk_rate) &&
> 			!mdss_mdp_perf_bw_check_pipe(&perf, pipe))
300c369,370
< 		if (mdata->has_decimation && (pipe->vert_deci < MAX_DECIMATION))
---
> 		if (mdata->has_decimation && (pipe->vert_deci < MAX_DECIMATION)
> 			&& !pipe->bwc_mode && !pipe->src_fmt->tile)
316,317c386,394
< 	rc = mdss_mdp_calc_phase_step(src, pipe->dst.w, &pipe->phase_step_x);
< 	if (rc) {
---
> 	if (pipe->scale.enable_pxl_ext)
> 		return 0;
> 	memset(&pipe->scale, 0, sizeof(struct mdp_scale_data));
> 	rc = mdss_mdp_calc_phase_step(src, pipe->dst.w,
> 			&pipe->scale.phase_step_x[0]);
> 	if (rc == -EOVERFLOW) {
> 		/* overflow on horizontal direction is acceptable */
> 		rc = 0;
> 	} else if (rc) {
324,325c401,407
< 	rc = mdss_mdp_calc_phase_step(src, pipe->dst.h, &pipe->phase_step_y);
< 	if (rc) {
---
> 	rc = mdss_mdp_calc_phase_step(src, pipe->dst.h,
> 			&pipe->scale.phase_step_y[0]);
> 
> 	if ((rc == -EOVERFLOW) && (pipe->type == MDSS_MDP_PIPE_TYPE_VIG)) {
> 		/* overflow on Qseed2 scaler is acceptable */
> 		rc = 0;
> 	} else if (rc) {
329a412,417
> 	pipe->scale.init_phase_x[0] = (pipe->scale.phase_step_x[0] -
> 					(1 << PHASE_STEP_SHIFT)) / 2;
> 	pipe->scale.init_phase_y[0] = (pipe->scale.phase_step_y[0] -
> 					(1 << PHASE_STEP_SHIFT)) / 2;
> 	return rc;
> }
331c419,439
< 	return 0;
---
> static inline void __mdss_mdp_overlay_set_chroma_sample(
> 	struct mdss_mdp_pipe *pipe)
> {
> 	pipe->chroma_sample_v = pipe->chroma_sample_h = 0;
> 
> 	switch (pipe->src_fmt->chroma_sample) {
> 	case MDSS_MDP_CHROMA_H1V2:
> 		pipe->chroma_sample_v = 1;
> 		break;
> 	case MDSS_MDP_CHROMA_H2V1:
> 		pipe->chroma_sample_h = 1;
> 		break;
> 	case MDSS_MDP_CHROMA_420:
> 		pipe->chroma_sample_v = 1;
> 		pipe->chroma_sample_h = 1;
> 		break;
> 	}
> 	if (pipe->horz_deci)
> 		pipe->chroma_sample_h = 0;
> 	if (pipe->vert_deci)
> 		pipe->chroma_sample_v = 0;
335,336c443,444
< 				       struct mdp_overlay *req,
< 				       struct mdss_mdp_pipe **ppipe)
---
> 	struct mdp_overlay *req, struct mdss_mdp_pipe **ppipe,
> 	struct mdss_mdp_pipe *left_blend_pipe)
342a451
> 	struct mdss_data_type *mdata = mfd_to_mdata(mfd);
345a455,456
> 	bool is_vig_needed = false;
> 	u32 left_lm_w = left_lm_w_from_mfd(mfd);
352c463
< 		return -ENOTSUPP;
---
> 		return -EOPNOTSUPP;
361c472
< 	if (req->flags & MDSS_MDP_RIGHT_MIXER)
---
> 	if (IS_RIGHT_MIXER_OV(req->flags, req->dst_rect.x, left_lm_w))
366,371c477,479
< 	pr_debug("pipe ctl=%u req id=%x mux=%d\n", mdp5_data->ctl->num, req->id,
< 			mixer_mux);
< 
< 	if (req->flags & (MDP_SOURCE_ROTATED_90 | MDP_BWC_EN))
< 		req->src.format =
< 			mdss_mdp_get_rotator_dst_format(req->src.format, 1);
---
> 	pr_debug("ctl=%u req id=%x mux=%d z_order=%d flags=0x%x dst_x:%d\n",
> 		mdp5_data->ctl->num, req->id, mixer_mux, req->z_order,
> 		req->flags, req->dst_rect.x);
378a487,503
> 	bwc_enabled = req->flags & MDP_BWC_EN;
> 	if (bwc_enabled || ((req->flags & MDP_SOURCE_ROTATED_90)
> 		&& ((mdata->mdp_rev < MDSS_MDP_HW_REV_102) || !fmt->is_yuv))) {
> 		req->src.format =
> 			mdss_mdp_get_rotator_dst_format(req->src.format, 1,
> 				bwc_enabled);
> 		fmt = mdss_mdp_get_format_params(req->src.format);
> 		if (!fmt) {
> 			pr_err("invalid pipe format %d\n", req->src.format);
> 			return -EINVAL;
> 		}
> 	}
> 
> 	ret = mdss_mdp_ov_xres_check(mfd, req);
> 	if (ret)
> 		return ret;
> 
383,384c508,509
< 	pipe = mdss_mdp_mixer_stage_pipe(mdp5_data->ctl, mixer_mux,
< 					req->z_order);
---
> 	pipe = mdss_mdp_get_staged_pipe(mdp5_data->ctl, mixer_mux,
> 		req->z_order, left_blend_pipe != NULL);
386,388c511,514
< 		pr_debug("replacing pnum=%d at stage=%d mux=%d\n",
< 				pipe->num, req->z_order, mixer_mux);
< 		mdss_mdp_mixer_pipe_unstage(pipe);
---
> 		pr_debug("replacing pnum=%d at stage=%d mux=%d id:0x%x %s\n",
> 			pipe->num, req->z_order, mixer_mux, req->id,
> 			left_blend_pipe ? "right blend" : "left blend");
> 		mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_left);
396a523,527
> 	if ((mdata->has_non_scalar_rgb) &&
> 		((req->src_rect.w != req->dst_rect.w) ||
> 			(req->src_rect.h != req->dst_rect.h)))
> 		is_vig_needed = true;
> 
398,418c529,537
< 		switch (req->pipe_type) {
<                 case PIPE_TYPE_VIG:
<                         pipe_type = MDSS_MDP_PIPE_TYPE_VIG;
<                         break;
<                 case PIPE_TYPE_RGB:
<                         pipe_type = MDSS_MDP_PIPE_TYPE_RGB;
<                         break;
<                 case PIPE_TYPE_DMA:
<                         pipe_type = MDSS_MDP_PIPE_TYPE_DMA;
<                         break;
<                 case PIPE_TYPE_AUTO:
<                 default:
<                         if (req->flags & MDP_OV_PIPE_FORCE_DMA)
<                                 pipe_type = MDSS_MDP_PIPE_TYPE_DMA;
<                         else if (fmt->is_yuv ||
<                                 (req->flags & MDP_OV_PIPE_SHARE))
<                                 pipe_type = MDSS_MDP_PIPE_TYPE_VIG;
<                         else
<                                 pipe_type = MDSS_MDP_PIPE_TYPE_RGB;
<                         break;
<                 }
---
> 		if (req->flags & MDP_OV_PIPE_FORCE_DMA)
> 			pipe_type = MDSS_MDP_PIPE_TYPE_DMA;
> 		else if (fmt->is_yuv || (req->flags & MDP_OV_PIPE_SHARE) ||
> 			is_vig_needed)
> 			pipe_type = MDSS_MDP_PIPE_TYPE_VIG;
> 		else
> 			pipe_type = MDSS_MDP_PIPE_TYPE_RGB;
> 
> 		pipe = mdss_mdp_pipe_alloc(mixer, pipe_type, left_blend_pipe);
420c539,546
< 		pipe = mdss_mdp_pipe_alloc(mixer, pipe_type);
---
> 		/* RGB pipes can be used instead of DMA */
> 		if (!pipe && (pipe_type == MDSS_MDP_PIPE_TYPE_DMA)) {
> 			pr_debug("giving RGB pipe for fb%d. flags:0x%x\n",
> 				mfd->index, req->flags);
> 			pipe_type = MDSS_MDP_PIPE_TYPE_RGB;
> 			pipe = mdss_mdp_pipe_alloc(mixer, pipe_type,
> 				left_blend_pipe);
> 		}
423,424c549,551
< 		if ((req->pipe_type == PIPE_TYPE_AUTO) && !pipe &&
< 			(pipe_type == MDSS_MDP_PIPE_TYPE_RGB)) {
---
> 		if (!pipe && pipe_type == MDSS_MDP_PIPE_TYPE_RGB) {
> 			pr_debug("giving ViG pipe for fb%d. flags:0x%x\n",
> 				mfd->index, req->flags);
426c553,554
< 			pipe = mdss_mdp_pipe_alloc(mixer, pipe_type);
---
> 			pipe = mdss_mdp_pipe_alloc(mixer, pipe_type,
> 				left_blend_pipe);
430,431c558,560
< 			pr_err("error allocating pipe\n");
< 			return -ENOMEM;
---
> 			pr_err("error allocating pipe. flags=0x%x\n",
> 				req->flags);
> 			return -ENODEV;
443c572
< 		pipe->mixer = mixer;
---
> 		pipe->mixer_left = mixer;
454c583,589
< 		if (pipe->mixer != mixer) {
---
> 		if (is_vig_needed && (pipe->type != MDSS_MDP_PIPE_TYPE_VIG)) {
> 			pr_err("pipe is non-scalar ndx=%x\n", req->id);
> 			ret = -EINVAL;
> 			goto exit_fail;
> 		}
> 
> 		if (pipe->mixer_left != mixer) {
457c592
< 						pipe->mixer->num, mixer->num,
---
> 					pipe->mixer_left->num, mixer->num,
462,466c597,614
< 			pr_debug("switching pipe mixer %d->%d pnum %d\n",
< 					pipe->mixer->num, mixer->num,
< 					pipe->num);
< 			mdss_mdp_mixer_pipe_unstage(pipe);
< 			pipe->mixer = mixer;
---
> 			pr_debug("switching pipe%d mixer %d->%d stage%d\n",
> 				pipe->num,
> 				pipe->mixer_left ? pipe->mixer_left->num : -1,
> 				mixer->num, req->z_order);
> 			mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_left);
> 			pipe->mixer_left = mixer;
> 		}
> 	}
> 
> 	if (left_blend_pipe) {
> 		if (pipe->priority <= left_blend_pipe->priority) {
> 			pr_debug("priority limitation. left:%d right%d\n",
> 				left_blend_pipe->priority, pipe->priority);
> 			ret = -EPERM;
> 			goto exit_fail;
> 		} else {
> 			pr_debug("pipe%d is a right_pipe\n", pipe->num);
> 			pipe->is_right_blend = true;
467a616,623
> 	} else if (pipe->is_right_blend) {
> 		/*
> 		 * pipe used to be right blend need to update mixer
> 		 * configuration to remove it as a right blend
> 		 */
> 		mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_left);
> 		mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_right);
> 		pipe->is_right_blend = false;
471d626
< 	bwc_enabled = req->flags & MDP_BWC_EN;
477c632
< 		pipe->bwc_mode = pipe->mixer->rotator_mode ?
---
> 		pipe->bwc_mode = pipe->mixer_left->rotator_mode ?
491a647,677
> 
> 	/*
> 	 * check if overlay span across two mixers and if source split is
> 	 * available. If yes, enable src_split_req flag so that during mixer
> 	 * staging, same pipe will be stagged on both layer mixers.
> 	 */
> 	if (mdata->has_src_split) {
> 		if ((mixer_mux == MDSS_MDP_MIXER_MUX_LEFT) &&
> 		    ((req->dst_rect.x + req->dst_rect.w) > mixer->width)) {
> 			if (req->dst_rect.x >= mixer->width) {
> 				pr_err("%pS: err dst_x can't lie in right half",
> 					__builtin_return_address(0));
> 				pr_cont(" flags:0x%x dst x:%d w:%d lm_w:%d\n",
> 					req->flags, req->dst_rect.x,
> 					req->dst_rect.w, mixer->width);
> 				ret = -EINVAL;
> 				goto exit_fail;
> 			} else {
> 				pipe->src_split_req = true;
> 			}
> 		} else {
> 			if (pipe->src_split_req) {
> 				mdss_mdp_mixer_pipe_unstage(pipe,
> 					pipe->mixer_right);
> 				pipe->mixer_right = NULL;
> 			}
> 			pipe->src_split_req = false;
> 		}
> 	}
> 
> 	memcpy(&pipe->scale, &req->scale, sizeof(struct mdp_scale_data));
492a679
> 	__mdss_mdp_overlay_set_chroma_sample(pipe);
494,501d680
< 	if((pipe->src.h > 2500) && (pipe->src.h > pipe->dst.h)
< 				&& (pipe->src.h - 2 <= pipe->dst.h)){ 
< 			pr_debug("[QCT_TEST] mixer_height : %d, width : %d \n",pipe->mixer->height,pipe->mixer->width); 
< 
< 			pipe->dst.h= pipe->src.h; 
< 			if(pipe->dst.h+pipe->dst.y > pipe->mixer->height) 
< 				pipe->dst.y -= (pipe->dst.h + pipe->dst.y - pipe->mixer->height); 
< 	} 
516c695,696
< 	if (fmt->is_yuv && !(pipe->flags & MDP_SOURCE_ROTATED_90)) {
---
> 	if (fmt->is_yuv && !(pipe->flags & MDP_SOURCE_ROTATED_90) &&
> 			!pipe->scale.enable_pxl_ext) {
520c700
< 				(pipe->flags & MDSS_MDP_RIGHT_MIXER))
---
> 		    IS_RIGHT_MIXER_OV(pipe->flags, pipe->dst.x, left_lm_w))
528a709
> 	req->priority = pipe->priority;
541d721
< 				pr_err("pp_cfg1 get from user was NULL \n");
549d728
< 				pr_err("pp_cfg2 get from user was NULL \n");
577d755
< 				pr_err("lut get from user was NULL \n");
585c763
< 	if (pipe->flags & MDP_DEINTERLACE) {
---
> 	if ((pipe->flags & MDP_DEINTERLACE) && !pipe->scale.enable_pxl_ext) {
609c787
< 		!mdp5_data->mdata->has_wfd_blk)
---
> 		(mdp5_data->mdata->wfd_mode == MDSS_MDP_WFD_SHARED))
614c792,793
< 		pr_debug("mdss_mdp_smp_reserve failed. ret=%d\n", ret);
---
> 		pr_debug("mdss_mdp_smp_reserve failed. pnum:%d ret=%d\n",
> 			pipe->num, ret);
618a798
> 	pipe->has_buf = 0;
626,637d805
< 	pr_debug("mixer:%d pipe:%s z_order:%d rotate90 : %d src.x:%d y:%d w:%d h:%d "
< 		"des_rect.x:%d y:%d w:%d h:%d\n", mixer_mux,
< 			pipe->ndx == BIT(0) ? "VG0" : pipe->ndx == BIT(1) ? "VG1" :
< 			pipe->ndx == BIT(2) ? "VG2" : pipe->ndx == BIT(3) ? "RGB0" :
< 			pipe->ndx == BIT(4) ? "RGB1" : pipe->ndx == BIT(5) ? "RGB2" :
< 			pipe->ndx == BIT(6) ? "DMA0" : "DMA1" ,
< 			req->z_order-MDSS_MDP_STAGE_0,
< 			req->flags & (MDP_SOURCE_ROTATED_90) ? 1 : 0,
< 			req->src_rect.x, req->src_rect.y, req->src_rect.w,
< 			req->src_rect.h, req->dst_rect.x, req->dst_rect.y,
< 			req->dst_rect.w, req->dst_rect.h);
< 
686c854
< 		ret = mdss_mdp_overlay_pipe_setup(mfd, req, &pipe);
---
> 		ret = mdss_mdp_overlay_pipe_setup(mfd, req, &pipe, NULL);
753,754d920
< 	mutex_lock(&free_list_purge_mutex);
< 
759,760d924
< 
< 	mutex_unlock(&free_list_purge_mutex);
788a953,954
> 	struct mdss_mdp_ctl *ctl = mfd_to_ctl(mfd);
> 	bool recovery_mode = false;
792,793d957
< 	__mdss_mdp_overlay_free_list_purge(mfd);
< 
797,799c961,983
< 		mdss_mdp_overlay_free_buf(&pipe->back_buf);
< 		__mdss_mdp_overlay_free_list_add(mfd, &pipe->front_buf);
< 		pipe->mfd = NULL;
---
> 
> 		/* make sure pipe fetch has been halted before freeing buffer */
> 		if (mdss_mdp_pipe_fetch_halt(pipe)) {
> 			/*
> 			 * if pipe is not able to halt. Enter recovery mode,
> 			 * by un-staging any pipes that are attached to mixer
> 			 * so that any freed pipes that are not able to halt
> 			 * can be staged in solid fill mode and be reset
> 			 * with next vsync
> 			 */
> 			if (!recovery_mode) {
> 				recovery_mode = true;
> 				mdss_mdp_mixer_unstage_all(ctl->mixer_left);
> 				mdss_mdp_mixer_unstage_all(ctl->mixer_right);
> 			}
> 			pipe->params_changed++;
> 			mdss_mdp_pipe_queue_data(pipe, NULL);
> 		}
> 	}
> 
> 	if (recovery_mode) {
> 		pr_warn("performing recovery sequence for fb%d\n", mfd->index);
> 		__overlay_kickoff_requeue(mfd);
801a986,987
> 	__mdss_mdp_overlay_free_list_purge(mfd);
> 
809,810c995,1006
< 	mutex_unlock(&mfd->lock);
< 	list_for_each_entry_safe(pipe, tmp, &destroy_pipes, cleanup_list)
---
> 
> 	list_for_each_entry_safe(pipe, tmp, &destroy_pipes, cleanup_list) {
> 		/*
> 		 * in case of secure UI, the buffer needs to be released as
> 		 * soon as session is closed.
> 		 */
> 		if (pipe->flags & MDP_SECURE_DISPLAY_OVERLAY_SESSION)
> 			mdss_mdp_overlay_free_buf(&pipe->front_buf);
> 		else
> 			__mdss_mdp_overlay_free_list_add(mfd, &pipe->front_buf);
> 		mdss_mdp_overlay_free_buf(&pipe->back_buf);
> 		list_del_init(&pipe->cleanup_list);
811a1008,1009
> 	}
> 	mutex_unlock(&mfd->lock);
846c1044
< 			mdss_mdp_mixer_pipe_unstage(pipe);
---
> 			mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_left);
867,871d1064
< 	if (!ctl) {
< 		pr_err("%s unable to access ctrl\n", __func__);
< 		return -ENODEV;
< 	}
< 
872a1066,1070
> 		if (mdp5_data->mdata->ulps) {
> 			mdss_mdp_footswitch_ctrl_ulps(1, &mfd->pdev->dev);
> 			mdss_mdp_ctl_restore(ctl);
> 		}
> 
874a1073,1074
> 		if (!mfd->panel_info->cont_splash_enabled)
> 			mdss_iommu_attach(mdp5_data->mdata);
880,885d1079
< 	rc = pm_runtime_get_sync(&mfd->pdev->dev);
< 	if (IS_ERR_VALUE(rc)) {
< 		pr_err("unable to resume with pm_runtime_get_sync rc=%d\n", rc);
< 		return rc;
< 	}
< 
946,953d1139
< 		} else {
< 			/* Add all the handed off pipes to the cleanup list */
< 			__mdss_mdp_handoff_cleanup_pipes(mfd,
< 				MDSS_MDP_PIPE_TYPE_RGB);
< 			__mdss_mdp_handoff_cleanup_pipes(mfd,
< 				MDSS_MDP_PIPE_TYPE_VIG);
< 			__mdss_mdp_handoff_cleanup_pipes(mfd,
< 				MDSS_MDP_PIPE_TYPE_DMA);
955,959c1141
< 		rc = mdss_mdp_ctl_splash_finish(ctl, mdp5_data->handoff);
< 		/*
< 		 * Remove the vote for footswitch even if above function
< 		 * returned error
< 		 */
---
> 		mdss_mdp_ctl_splash_finish(ctl, mdp5_data->handoff);
961,963d1142
< 		if (rc)
< 			goto error;
< 
991,999c1170
< #if defined(CONFIG_MDNIE_LITE_TUNING)
< #if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_CMD_FULL_HD_PT_PANEL) \
< 		|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_YOUM_CMD_FULL_HD_PT_PANEL)
< static bool mdss_first_init = true;
< #endif
< #endif
< 
< int mdss_mdp_overlay_kickoff(struct msm_fb_data_type *mfd,
< 				struct mdp_display_commit *data)
---
> static int __overlay_queue_pipes(struct msm_fb_data_type *mfd)
1006,1039d1176
< 	int sd_in_pipe = 0;
< 
< 	if (!ctl) {
< 		pr_warn("kickoff on fb=%d without a ctl attched\n", mfd->index);
< 		return ret;
< 	}
< 
< 	if (ctl->shared_lock)
< 		mutex_lock(ctl->shared_lock);
< 
< 	mutex_lock(&mdp5_data->ov_lock);
< 	mutex_lock(&mfd->lock);
< 
< 	/*
< 	 * check if there is a secure display session
< 	 */
< 	list_for_each_entry(pipe, &mdp5_data->pipes_used, used_list) {
< 		if (pipe->flags & MDP_SECURE_DISPLAY_OVERLAY_SESSION) {
< 			sd_in_pipe |= 1;
< 			pr_debug("Secure pipe: %u : %08X\n",
< 					pipe->num, pipe->flags);
< 		}
< 	}
< 	/*
< 	 * If there is no secure display session and sd_enabled, disable the
< 	 * secure display session
< 	 */
< 	if (!sd_in_pipe && mdp5_data->sd_enabled) {
< 		if (0 == mdss_mdp_overlay_sd_ctrl(mfd, 0))
< 			mdp5_data->sd_enabled = 0;
< 	}
< 
< 	mdss_mdp_ctl_notify(ctl, MDP_NOTIFY_FRAME_BEGIN);
< 	mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_ON, false);
1041,1044d1177
< 	if (data)
< 		mdss_mdp_set_roi(ctl, data);
< 
< 	pipes_used_dbg = &mdp5_data->pipes_used;
1062,1067d1194
< #ifdef CONFIG_FB_MSM_CAMERA_CSC
< 		if (pre_csc_update != csc_update) {
< 			if (pipe->type == MDSS_MDP_PIPE_TYPE_VIG)
< 				pipe->params_changed = 1;
< 		}
< #endif
1069c1196,1197
< 		    (ctl->shared_lock && !ctl->mdata->has_wfd_blk)) {
---
> 		    (ctl->shared_lock &&
> 		    (ctl->mdata->wfd_mode == MDSS_MDP_WFD_SHARED))) {
1072c1200
< 						&pipe->req_data, &pipe);
---
> 					&pipe->req_data, &pipe, NULL);
1079,1080c1207
< 				mutex_unlock(&mfd->lock);
< 				goto commit_fail;
---
> 				return ret;
1085,1090c1212,1214
< 			if (!tmp) {
< 				mutex_unlock(&mfd->lock);
< 				ret = -EINVAL;
< 				goto commit_fail;
< 			}
< 			pipe->mixer = mdss_mdp_mixer_get(tmp,
---
> 			if (!tmp)
> 				return -EINVAL;
> 			pipe->mixer_left = mdss_mdp_mixer_get(tmp,
1092a1217,1221
> 
> 		/* ensure pipes are always reconfigured after power off/on */
> 		if (ctl->play_cnt == 0)
> 			pipe->params_changed++;
> 
1095,1097d1223
< 		} else if (ctl->play_cnt == 0 && pipe->front_buf.num_planes) {
< 			pipe->params_changed++;
< 			buf = &pipe->front_buf;
1112c1238,1280
< 			mdss_mdp_mixer_pipe_unstage(pipe);
---
> 			mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_left);
> 		}
> 	}
> 
> 	return 0;
> }
> 
> static void __overlay_kickoff_requeue(struct msm_fb_data_type *mfd)
> {
> 	struct mdss_mdp_ctl *ctl = mfd_to_ctl(mfd);
> 
> 	mdss_mdp_display_commit(ctl, NULL);
> 	mdss_mdp_display_wait4comp(ctl);
> 
> 	__overlay_queue_pipes(mfd);
> 
> 	mdss_mdp_display_commit(ctl, NULL);
> 	mdss_mdp_display_wait4comp(ctl);
> }
> 
> int mdss_mdp_overlay_kickoff(struct msm_fb_data_type *mfd,
> 				struct mdp_display_commit *data)
> {
> 	struct mdss_overlay_private *mdp5_data = mfd_to_mdp5_data(mfd);
> 	struct mdss_mdp_pipe *pipe;
> 	struct mdss_mdp_ctl *ctl = mfd_to_ctl(mfd);
> 	int ret = 0;
> 	int sd_in_pipe = 0;
> 
> 	if (ctl->shared_lock)
> 		mutex_lock(ctl->shared_lock);
> 
> 	mutex_lock(&mdp5_data->ov_lock);
> 	mutex_lock(&mfd->lock);
> 
> 	/*
> 	 * check if there is a secure display session
> 	 */
> 	list_for_each_entry(pipe, &mdp5_data->pipes_used, used_list) {
> 		if (pipe->flags & MDP_SECURE_DISPLAY_OVERLAY_SESSION) {
> 			sd_in_pipe = 1;
> 			pr_debug("Secure pipe: %u : %08X\n",
> 					pipe->num, pipe->flags);
1113a1282,1290
> 	}
> 	/*
> 	 * If there is no secure display session and sd_enabled, disable the
> 	 * secure display session
> 	 */
> 	if (!sd_in_pipe && mdp5_data->sd_enabled) {
> 		if (0 == mdss_mdp_overlay_sd_ctrl(mfd, 0))
> 			mdp5_data->sd_enabled = 0;
> 	}
1115,1123c1292,1296
< 		pr_debug("mixer:%d pipe:%s z_order:%d flag : 0x%x src.x:%d y:%d w:%d h:%d "
< 			"des_rect.x:%d y:%d w:%d h:%d\n", pipe->mixer->num,
< 			pipe->ndx == BIT(0) ? "VG0" : pipe->ndx == BIT(1) ? "VG1" :
< 			pipe->ndx == BIT(2) ? "VG2" : pipe->ndx == BIT(3) ? "RGB0" :
< 			pipe->ndx == BIT(4) ? "RGB1" : pipe->ndx == BIT(5) ? "RGB2" :
< 			pipe->ndx == BIT(6) ? "DMA0" : "DMA1" ,
< 			pipe->mixer_stage - MDSS_MDP_STAGE_0, pipe->flags,
< 			pipe->src.x, pipe->src.y, pipe->src.w, pipe->src.h, 
< 			pipe->dst.x, pipe->dst.y, pipe->dst.w, pipe->dst.h);
---
> 	mdss_mdp_ctl_notify(ctl, MDP_NOTIFY_FRAME_BEGIN);
> 	mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_ON, false);
> 
> 	if (data)
> 		mdss_mdp_set_roi(ctl, data);
1124a1298,1305
> 	/*
> 	 * Setup pipe in solid fill before unstaging,
> 	 * to ensure no fetches are happening after dettach or reattach.
> 	 */
> 	list_for_each_entry(pipe, &mdp5_data->pipes_cleanup, cleanup_list) {
> 		mdss_mdp_pipe_queue_data(pipe, NULL);
> 		mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_left);
> 		mdss_mdp_mixer_pipe_unstage(pipe, pipe->mixer_right);
1127,1130c1308,1309
< #ifdef CONFIG_FB_MSM_CAMERA_CSC
< 	if (pre_csc_update != csc_update)
< 			pre_csc_update = csc_update;
< #endif
---
> 	ret = __overlay_queue_pipes(mfd);
> 
1136,1137d1314
< 	atomic_set(&mfd->kickoff_pending, 0);
< 	wake_up_all(&mfd->kickoff_wait_q);
1143d1319
< 	mutex_unlock(&mdp5_data->ov_lock);
1147d1322
< 	mutex_lock(&mdp5_data->ov_lock);
1151c1326
< 		if (!mdp5_data->sd_enabled && (sd_in_pipe == 1)) {
---
> 		if (!mdp5_data->sd_enabled && sd_in_pipe) {
1161,1173d1335
< #if defined(CONFIG_MDNIE_LITE_TUNING)
< #if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_CMD_FULL_HD_PT_PANEL) \
< 		|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_YOUM_CMD_FULL_HD_PT_PANEL)
< 	if(mdss_first_init)
< 	{
< 		mdss_mdp_ctl_intf_event(mdp5_data->ctl, MDSS_EVENT_MDNIE_DEFAULT_UPDATE, NULL);
< 		mdss_first_init = false;
< 	}
< #endif
< #endif
< 
< #if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_CMD_FULL_HD_PT_PANEL) || defined (CONFIG_FB_MSM_MIPI_SAMSUNG_OCTA_CMD_WQHD_PT_PANEL)\
< 	|| defined(CONFIG_FB_MSM_MIPI_SAMSUNG_YOUM_CMD_FULL_HD_PT_PANEL)
1175,1178c1337
< #endif
< #if defined(CONFIG_FB_MSM_MDSS_SDC_WXGA_PANEL) &&  !defined(CONFIG_MACH_DEGASLTE_SPR)
<  	mdss_mdp_ctl_intf_event(mdp5_data->ctl, MDSS_EVENT_BACKLIGHT_LATE_ON, NULL);
<  #endif
---
> 
1187,1191d1345
< 	
< #if defined(CONFIG_FB_MSM8x26_MDSS_CHECK_LCD_CONNECTION)
< 	if(get_lcd_attached() == 0)
< 		return 0;
< #endif
1224d1377
< 			mdss_mdp_mixer_pipe_unstage(pipe);
1257,1265d1409
< #if defined(CONFIG_FB_MSM_MDSS_S6E8AA0A_HD_PANEL)
< 	if(lcd_connected_status == 1){
< 	if (!mfd->panel_power_on && !err_fg_working) {
< 		ret = -EPERM;
< 		goto done;
< 	}
< 	}
< 	
< #else
1270,1271d1413
< #endif
< 
1377a1520
> 
1382c1525,1527
< 	flags |= (pipe->flags & MDP_SECURE_DISPLAY_OVERLAY_SESSION);
---
> 
> 	if (!mfd->panel_info->cont_splash_enabled)
> 		mdss_iommu_attach(mdata);
1386,1387c1531,1532
< 		pr_warn("dropped buffer pnum=%d play=%d addr=0x%x\n",
< 			pipe->num, pipe->play_cnt, src_data->p[0].addr);
---
> 		pr_warn("dropped buffer pnum=%d play=%d addr=0x%pa\n",
> 			pipe->num, pipe->play_cnt, &src_data->p[0].addr);
1394a1540
> 	pipe->has_buf = 1;
1399a1546,1578
> static void mdss_mdp_overlay_force_cleanup(struct msm_fb_data_type *mfd)
> {
> 	struct mdss_overlay_private *mdp5_data = mfd_to_mdp5_data(mfd);
> 	struct mdss_mdp_ctl *ctl = mdp5_data->ctl;
> 	int ret;
> 
> 	pr_debug("forcing cleanup to unset dma pipes on fb%d\n", mfd->index);
> 
> 	/*
> 	 * video mode panels require the layer to be unstaged and wait for
> 	 * vsync to be able to release buffer.
> 	 */
> 	if (ctl && ctl->is_video_mode) {
> 		ret = mdss_mdp_display_commit(ctl, NULL);
> 		if (!IS_ERR_VALUE(ret))
> 			mdss_mdp_display_wait4comp(ctl);
> 	}
> 
> 	mdss_mdp_overlay_cleanup(mfd);
> }
> 
> static void mdss_mdp_overlay_force_dma_cleanup(struct mdss_data_type *mdata)
> {
> 	struct mdss_mdp_pipe *pipe;
> 	int i;
> 
> 	for (i = 0; i < mdata->ndma_pipes; i++) {
> 		pipe = mdata->dma_pipes + i;
> 		if (atomic_read(&pipe->ref_cnt) && pipe->mfd)
> 			mdss_mdp_overlay_force_cleanup(pipe->mfd);
> 	}
> }
> 
1423a1603,1604
> 		mdss_mdp_overlay_force_dma_cleanup(mfd_to_mdata(mfd));
> 
1445,1447c1626,1627
< 	pipe = mdss_mdp_mixer_stage_pipe(mdp5_data->ctl,
< 					MDSS_MDP_MIXER_MUX_LEFT,
< 					 MDSS_MDP_STAGE_BASE);
---
> 	pipe = mdss_mdp_get_staged_pipe(mdp5_data->ctl,
> 		MDSS_MDP_MIXER_MUX_LEFT, MDSS_MDP_STAGE_BASE, false);
1451,1453c1631,1632
< 	pipe = mdss_mdp_mixer_stage_pipe(mdp5_data->ctl,
< 					MDSS_MDP_MIXER_MUX_RIGHT,
< 					 MDSS_MDP_STAGE_BASE);
---
> 	pipe = mdss_mdp_get_staged_pipe(mdp5_data->ctl,
> 		MDSS_MDP_MIXER_MUX_RIGHT, MDSS_MDP_STAGE_BASE, false);
1466c1645,1646
< 					int mixer_mux)
---
> 					int mixer_mux,
> 					struct mdp_overlay *req_ov)
1469a1650,1653
> 	int ret;
> 
> 	pipe = mdss_mdp_get_staged_pipe(mdp5_data->ctl, mixer_mux,
> 		MDSS_MDP_STAGE_BASE, false);
1471,1472d1654
< 	pipe = mdss_mdp_mixer_stage_pipe(mdp5_data->ctl, mixer_mux,
< 					 MDSS_MDP_STAGE_BASE);
1474,1475d1655
< 		struct mdp_overlay req;
< 		struct fb_info *fbi = mfd->fbi;
1477d1656
< 		int ret, bpp;
1486c1665,1681
< 		memset(&req, 0, sizeof(req));
---
> 		if (req_ov == NULL) {
> 			struct mdp_overlay req;
> 			struct fb_info *fbi = mfd->fbi;
> 			int bpp;
> 
> 			memset(&req, 0, sizeof(req));
> 
> 			bpp = fbi->var.bits_per_pixel / 8;
> 			req.id = MSMFB_NEW_REQUEST;
> 			req.src.format = mfd->fb_imgType;
> 			req.src.height = fbi->var.yres;
> 			req.src.width = fbi->fix.line_length / bpp;
> 			if (mixer_mux == MDSS_MDP_MIXER_MUX_RIGHT) {
> 				if (req.src.width <= mixer->width) {
> 					pr_warn("right fb pipe not needed\n");
> 					return -EINVAL;
> 				}
1488,1496c1683,1688
< 		bpp = fbi->var.bits_per_pixel / 8;
< 		req.id = MSMFB_NEW_REQUEST;
< 		req.src.format = mfd->fb_imgType;
< 		req.src.height = fbi->var.yres;
< 		req.src.width = fbi->fix.line_length / bpp;
< 		if (mixer_mux == MDSS_MDP_MIXER_MUX_RIGHT) {
< 			if (req.src.width <= mixer->width) {
< 				pr_warn("right fb pipe not needed\n");
< 				return -EINVAL;
---
> 				req.src_rect.x = mixer->width;
> 				req.src_rect.w = fbi->var.xres - mixer->width;
> 			} else {
> 				req.src_rect.x = 0;
> 				req.src_rect.w = MIN(fbi->var.xres,
> 								mixer->width);
1499,1513c1691,1694
< 			req.flags |= MDSS_MDP_RIGHT_MIXER;
< 			req.src_rect.x = mixer->width;
< 			req.src_rect.w = fbi->var.xres - mixer->width;
< 		} else {
< 			req.src_rect.x = 0;
< 			req.src_rect.w = MIN(fbi->var.xres, mixer->width);
< 		}
< 
< 		req.src_rect.y = 0;
< 		req.src_rect.h = req.src.height;
< 		req.dst_rect.x = 0;
< 		req.dst_rect.y = 0;
< 		req.dst_rect.w = req.src_rect.w;
< 		req.dst_rect.h = req.src_rect.h;
< 		req.z_order = MDSS_MDP_STAGE_BASE;
---
> 			req.src_rect.y = 0;
> 			req.src_rect.h = req.src.height;
> 			req.dst_rect = req.src_rect;
> 			req.z_order = MDSS_MDP_STAGE_BASE;
1515c1696
< 		pr_debug("allocating base pipe mux=%d\n", mixer_mux);
---
> 			pr_debug("allocating base pipe mux=%d\n", mixer_mux);
1517,1519c1698,1718
< 		ret = mdss_mdp_overlay_pipe_setup(mfd, &req, &pipe);
< 		if (ret)
< 			return ret;
---
> 			ret = mdss_mdp_overlay_pipe_setup(mfd, &req, &pipe,
> 				NULL);
> 			if (ret)
> 				return ret;
> 		} else {
> 			if (mixer_mux == MDSS_MDP_MIXER_MUX_RIGHT) {
> 				req_ov->id = MSMFB_NEW_REQUEST;
> 				req_ov->src_rect.w = MIN(mixer->width,
> 						req_ov->src_rect.w >> 1);
> 				req_ov->dst_rect.w = req_ov->src_rect.w;
> 				req_ov->src_rect.x = req_ov->src_rect.w;
> 				/*
> 				 * following dst_x assigment will have two
> 				 * different outcomes depending on the chipset's
> 				 * source split capability. If non-src-split
> 				 * chip-set then left mixer width will be
> 				 * deducted from dst_x later on inside
> 				 * mdss_mdp_ov_xres_check function.
> 				 */
> 				req_ov->dst_rect.x = mixer->width;
> 			}
1521c1720,1724
< 		pr_debug("ctl=%d pnum=%d\n", mdp5_data->ctl->num, pipe->num);
---
> 			ret = mdss_mdp_overlay_pipe_setup(mfd, req_ov, &pipe,
> 				NULL);
> 			if (ret)
> 				return ret;
> 		}
1523a1727,1728
> 	pr_debug("ctl=%d pnum=%d\n", mdp5_data->ctl->num, pipe->num);
> 
1528c1733,1736
< static void mdss_mdp_overlay_pan_display(struct msm_fb_data_type *mfd)
---
> static void mdss_mdp_overlay_pan_display(struct msm_fb_data_type *mfd,
> 					struct mdp_overlay *req,
> 					int image_size,
> 					int *pipe_ndx)
1559a1768
> 	mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_ON, false);
1576,1577c1785,1786
< 
< 	ret = mdss_mdp_overlay_get_fb_pipe(mfd, &pipe, MDSS_MDP_MIXER_MUX_LEFT);
---
> 	ret = mdss_mdp_overlay_get_fb_pipe(mfd, &pipe,
> 					MDSS_MDP_MIXER_MUX_LEFT, req);
1586a1796,1797
> 	if (pipe_ndx)
> 		pipe_ndx[0] = pipe->ndx;
1592c1803
< 			goto pan_display_error;
---
> 			goto attach_err;
1600c1811,1814
< 	buf->p[0].len = fbi->fix.smem_len - offset;
---
> 	if (image_size)
> 		buf->p[0].len = image_size;
> 	else
> 		buf->p[0].len = fbi->fix.smem_len - offset;
1601a1816
> 	pipe->has_buf = 1;
1606c1821
< 						   MDSS_MDP_MIXER_MUX_RIGHT);
---
> 					   MDSS_MDP_MIXER_MUX_RIGHT, req);
1609c1824
< 			goto pan_display_error;
---
> 			goto attach_err;
1613c1828
< 			goto pan_display_error;
---
> 			goto attach_err;
1614a1830,1832
> 		if (pipe_ndx)
> 			pipe_ndx[1] = pipe->ndx;
> 
1615a1834
> 		pipe->has_buf = 1;
1623a1843
> 	mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_OFF, false);
1625a1846,1852
> attach_err:
> 	mutex_unlock(&mdp5_data->ov_lock);
> 	mdss_mdp_overlay_unset(mfd, pipe->ndx);
> 	if (pipe_ndx)
> 		pipe_ndx[0] = INVALID_PIPE_INDEX;
> 	mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_OFF, false);
> 	return;
1626a1854
> 	mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_OFF, false);
1789c2017,2019
< 			&& !mdp5_data->ctl->power_on))
---
> 			&& !mdp5_data->ctl->power_on)) {
> 		if (mdp5_data->ctl)
> 			pr_warn("%s:power_on status: %d\n", __func__, mdp5_data->ctl->power_on);
1790a2021
> 	}
1884c2115,2128
< 	int off, ret = 0;
---
> 	int ret = 0;
> 	u32 xres = mfd->fbi->var.xres;
> 	u32 yres = mfd->fbi->var.yres;
> 	u32 start_x = img->dx;
> 	u32 start_y = img->dy;
> 	u32 roi_x = 0;
> 	u32 roi_y = 0;
> 	int roi_w = 0;
> 	int roi_h = 0;
> 	int roi_size = 0;
> 
> 	mixer = mdss_mdp_mixer_get(mdp5_data->ctl, MDSS_MDP_MIXER_MUX_DEFAULT);
> 	if (!mixer)
> 		return -ENODEV;
1905c2149
< 			return -ENOMEM;
---
> 			return ret;
1907d2150
< 	}
1909,1910c2152,2154
< 	mixer = mdss_mdp_mixer_get(mdp5_data->ctl, MDSS_MDP_MIXER_MUX_DEFAULT);
< 	off = MDSS_MDP_REG_LM_OFFSET(mixer->num);
---
> 		mixer->cursor_hotx = 0;
> 		mixer->cursor_hoty = 0;
> 	}
1914c2158
< 		(img->depth != 32))
---
> 		(img->depth != 32) || (start_x >= xres) || (start_y >= yres))
1921c2165,2191
< 	blendcfg = MDSS_MDP_REG_READ(off + MDSS_MDP_REG_LM_CURSOR_BLEND_CONFIG);
---
> 	blendcfg = mdp_mixer_read(mixer, MDSS_MDP_REG_LM_CURSOR_BLEND_CONFIG);
> 
> 	if (cursor->set & FB_CUR_SETHOT) {
> 		if ((cursor->hot.x < img->width) &&
> 			(cursor->hot.y < img->height)) {
> 			mixer->cursor_hotx = cursor->hot.x;
> 			mixer->cursor_hoty = cursor->hot.y;
> 			 /* Update cursor position */
> 			cursor->set |= FB_CUR_SETPOS;
> 		} else {
> 			pr_err("Invalid cursor hotspot coordinates\n");
> 			return -EINVAL;
> 		}
> 	}
> 
> 	if (start_x > mixer->cursor_hotx) {
> 		start_x -= mixer->cursor_hotx;
> 	} else {
> 		roi_x = mixer->cursor_hotx - start_x;
> 		start_x = 0;
> 	}
> 	if (start_y > mixer->cursor_hoty) {
> 		start_y -= mixer->cursor_hoty;
> 	} else {
> 		roi_y = mixer->cursor_hoty - start_y;
> 		start_y = 0;
> 	}
1923,1925c2193,2203
< 	if (cursor->set & FB_CUR_SETPOS)
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_START_XY,
< 				   (img->dy << 16) | img->dx);
---
> 	roi_w = min(xres - start_x, img->width - roi_x);
> 	roi_h = min(yres - start_y, img->height - roi_y);
> 	roi_size = (roi_h << 16) | roi_w;
> 
> 	if (cursor->set & FB_CUR_SETPOS) {
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_XY,
> 				(roi_y << 16) | roi_x);
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_START_XY,
> 				(start_y << 16) | start_x);
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_SIZE, roi_size);
> 	}
1928c2206,2207
< 		int calpha_en, transp_en, alpha, size, cursor_addr;
---
> 		int calpha_en, transp_en, alpha, size;
> 		u32 cursor_addr;
1931c2210,2212
< 		if (ret)
---
> 		if (ret) {
> 			pr_err("copy_from_user error. rc=%d\n", ret);
> 			mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_OFF, false);
1932a2214
> 		}
1934c2216
< 		if (is_mdss_iommu_attached())
---
> 		if (is_mdss_iommu_attached()) {
1936c2218,2223
< 		else
---
> 		} else {
> 			if (MDSS_LPAE_CHECK(mfd->cursor_buf_phys)) {
> 				pr_err("can't access phy mem >4GB w/o iommu\n");
> 				mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_OFF, false);
> 				return -ERANGE;
> 			}
1937a2225
> 		}
1952,1954c2240,2242
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_IMG_SIZE, size);
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_SIZE, size);
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_STRIDE,
---
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_IMG_SIZE, size);
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_SIZE, roi_size);
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_STRIDE,
1956c2244
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_BASE_ADDR,
---
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_BASE_ADDR,
1963c2251
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_BLEND_CONFIG,
---
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_BLEND_CONFIG,
1966c2254
< 			MDSS_MDP_REG_WRITE(off +
---
> 			mdp_mixer_write(mixer,
1971c2259
< 			MDSS_MDP_REG_WRITE(off +
---
> 			mdp_mixer_write(mixer,
1975c2263
< 			MDSS_MDP_REG_WRITE(off +
---
> 			mdp_mixer_write(mixer,
1978c2266
< 			MDSS_MDP_REG_WRITE(off +
---
> 			mdp_mixer_write(mixer,
1982c2270
< 			MDSS_MDP_REG_WRITE(off +
---
> 			mdp_mixer_write(mixer,
1985a2274,2276
> 
> 		mixer->cursor_hotx = 0;
> 		mixer->cursor_hoty = 0;
1997c2288
< 		MDSS_MDP_REG_WRITE(off + MDSS_MDP_REG_LM_CURSOR_BLEND_CONFIG,
---
> 		mdp_mixer_write(mixer, MDSS_MDP_REG_LM_CURSOR_BLEND_CONFIG,
2293a2585,2672
> /*
>  * This routine serves two purposes.
>  * 1. Propagate overlay_id returned from sorted list to original list
>  *    to user-space.
>  * 2. In case of error processing sorted list, map the error overlay's
>  *    index to original list because user-space is not aware of the sorted list.
>  */
> static int __mdss_overlay_map(struct mdp_overlay *ovs,
> 	struct mdp_overlay *op_ovs, int num_ovs, int num_ovs_processed)
> {
> 	int i = num_ovs_processed, j, k;
> 
> 	for (j = 0; j < num_ovs; j++) {
> 		for (k = 0; k < num_ovs; k++) {
> 			if ((ovs[j].dst_rect.x == op_ovs[k].dst_rect.x) &&
> 			    (ovs[j].z_order == op_ovs[k].z_order)) {
> 				op_ovs[k].id = ovs[j].id;
> 				op_ovs[k].priority = ovs[j].priority;
> 				break;
> 			}
> 		}
> 		if ((i != num_ovs) && (i != j) &&
> 		    (ovs[j].dst_rect.x == op_ovs[k].dst_rect.x) &&
> 		    (ovs[i].z_order == op_ovs[k].z_order)) {
> 			pr_debug("mapped %d->%d\n", i, j);
> 			i = j;
> 		}
> 	}
> 
> 	return i;
> }
> 
> static inline void __overlay_swap_func(void *a, void *b, int size)
> {
> 	swap(*(struct mdp_overlay *)a, *(struct mdp_overlay *)b);
> }
> 
> static inline int __zorder_dstx_cmp_func(const void *a, const void *b)
> {
> 	int rc = 0;
> 	const struct mdp_overlay *ov1 = a;
> 	const struct mdp_overlay *ov2 = b;
> 
> 	if (ov1->z_order < ov2->z_order)
> 		rc = -1;
> 	else if ((ov1->z_order == ov2->z_order) &&
> 		 (ov1->dst_rect.x < ov2->dst_rect.x))
> 		rc = -1;
> 
> 	return rc;
> }
> 
> /*
>  * first sort list of overlays based on z_order and then within
>  * same z_order sort them on dst_x.
>  */
> static int __mdss_overlay_src_split_sort(struct msm_fb_data_type *mfd,
> 	struct mdp_overlay *ovs, int num_ovs)
> {
> 	int i;
> 	int left_lm_zo_cnt[MDSS_MDP_MAX_STAGE] = {0};
> 	int right_lm_zo_cnt[MDSS_MDP_MAX_STAGE] = {0};
> 	u32 left_lm_w = left_lm_w_from_mfd(mfd);
> 
> 	sort(ovs, num_ovs, sizeof(struct mdp_overlay), __zorder_dstx_cmp_func,
> 		__overlay_swap_func);
> 
> 	for (i = 0; i < num_ovs; i++) {
> 		if (ovs[i].dst_rect.x < left_lm_w) {
> 			if (left_lm_zo_cnt[ovs[i].z_order] == 2) {
> 				pr_err("more than 2 ov @ stage%d on left lm\n",
> 					ovs[i].z_order);
> 				return -EINVAL;
> 			}
> 			left_lm_zo_cnt[ovs[i].z_order]++;
> 		} else {
> 			if (right_lm_zo_cnt[ovs[i].z_order] == 2) {
> 				pr_err("more than 2 ov @ stage%d on right lm\n",
> 					ovs[i].z_order);
> 				return -EINVAL;
> 			}
> 			right_lm_zo_cnt[ovs[i].z_order]++;
> 		}
> 	}
> 
> 	return 0;
> }
> 
2295,2296c2674
< 		struct mdp_overlay_list *ovlist,
< 		struct mdp_overlay *overlays)
---
> 	struct mdp_overlay_list *ovlist, struct mdp_overlay *ip_ovs)
2297a2676,2681
> 	int ret, i;
> 	int new_reqs = 0, left_cnt = 0, right_cnt = 0;
> 	int num_ovs = ovlist->num_overlays;
> 	u32 left_lm_w = left_lm_w_from_mfd(mfd);
> 
> 	struct mdss_data_type *mdata = mfd_to_mdata(mfd);
2299,2303c2683,2691
< 	struct mdss_mdp_pipe *pipe;
< 	struct mdp_overlay *req;
< 	int ret = 0;
< 	int i;
< 	u32 new_reqs = 0;
---
> 
> 	struct mdp_overlay *sorted_ovs = NULL;
> 	struct mdp_overlay *req, *prev_req;
> 
> 	struct mdss_mdp_pipe *pipe, *left_blend_pipe;
> 	struct mdss_mdp_pipe *right_plist[MAX_PIPES_PER_LM] = { 0 };
> 	struct mdss_mdp_pipe *left_plist[MAX_PIPES_PER_LM] = { 0 };
> 
> 	bool sort_needed = mdata->has_src_split && (num_ovs > 1);
2314,2315c2702,2717
< 	pr_debug("prepare fb%d num_overlays=%d\n", mfd->index,
< 			ovlist->num_overlays);
---
> 	if (sort_needed) {
> 		sorted_ovs = kzalloc(num_ovs * sizeof(*ip_ovs), GFP_KERNEL);
> 		if (!sorted_ovs) {
> 			pr_err("error allocating ovlist mem\n");
> 			return -ENOMEM;
> 		}
> 		memcpy(sorted_ovs, ip_ovs, num_ovs * sizeof(*ip_ovs));
> 		ret = __mdss_overlay_src_split_sort(mfd, sorted_ovs, num_ovs);
> 		if (ret) {
> 			pr_err("src_split_sort failed. ret=%d\n", ret);
> 			kfree(sorted_ovs);
> 			return ret;
> 		}
> 	}
> 
> 	pr_debug("prepare fb%d num_ovs=%d\n", mfd->index, num_ovs);
2317,2318c2719,2739
< 	for (i = 0; i < ovlist->num_overlays; i++) {
< 		req = overlays + i;
---
> 	for (i = 0; i < num_ovs; i++) {
> 		left_blend_pipe = NULL;
> 
> 		if (sort_needed) {
> 			req = &sorted_ovs[i];
> 			prev_req = (i > 0) ? &sorted_ovs[i - 1] : NULL;
> 
> 			/*
> 			 * check if current overlay is at same z_order as
> 			 * previous one and qualifies as a right blend. If yes,
> 			 * pass a pointer to the pipe representing previous
> 			 * overlay or in other terms left blend overlay.
> 			 */
> 			if (prev_req && (prev_req->z_order == req->z_order) &&
> 			    is_ov_right_blend(&prev_req->dst_rect,
> 				    &req->dst_rect, left_lm_w)) {
> 				left_blend_pipe = pipe;
> 			}
> 		} else {
> 			req = &ip_ovs[i];
> 		}
2321c2742,2743
< 		ret = mdss_mdp_overlay_pipe_setup(mfd, req, &pipe);
---
> 		ret = mdss_mdp_overlay_pipe_setup(mfd, req, &pipe,
> 			left_blend_pipe);
2326a2749,2752
> 		pr_debug("pnum:%d id:0x%x flags:0x%x dst_x:%d l_blend_pnum%d\n",
> 			pipe->num, req->id, req->flags, req->dst_rect.x,
> 			left_blend_pipe ? left_blend_pipe->num : -1);
> 
2329a2756,2773
> 
> 		if (IS_RIGHT_MIXER_OV(pipe->flags, pipe->dst.x, left_lm_w)) {
> 			if (right_cnt >= MAX_PIPES_PER_LM) {
> 				pr_err("too many pipes on right mixer\n");
> 				ret = -EINVAL;
> 				goto validate_exit;
> 			}
> 			right_plist[right_cnt] = pipe;
> 			right_cnt++;
> 		} else {
> 			if (left_cnt >= MAX_PIPES_PER_LM) {
> 				pr_err("too many pipes on left mixer\n");
> 				ret = -EINVAL;
> 				goto validate_exit;
> 			}
> 			left_plist[left_cnt] = pipe;
> 			left_cnt++;
> 		}
2331a2776,2778
> 	ret = mdss_mdp_perf_bw_check(mdp5_data->ctl, left_plist, left_cnt,
> 			right_plist, right_cnt);
> 
2333c2780,2788
< 	if (IS_ERR_VALUE(ret))
---
> 	if (sort_needed)
> 		ovlist->processed_overlays =
> 			__mdss_overlay_map(sorted_ovs, ip_ovs, num_ovs, i);
> 	else
> 		ovlist->processed_overlays = i;
> 
> 	if (IS_ERR_VALUE(ret)) {
> 		pr_debug("err=%d total_ovs:%d processed:%d\n",
> 			ret, num_ovs, ovlist->processed_overlays);
2334a2790
> 	}
2337c2793
< 	ovlist->processed_overlays = i;
---
> 	kfree(sorted_ovs);
2396d2851
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_MDP_PP\n", __func__);
2401d2855
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_HISTOGRAM_START\n", __func__);
2403d2856
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_HISTOGRAM_STOP\n", __func__);
2405d2857
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_HISTOGRAM\n", __func__);
2410d2861
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_GET\n", __func__);
2427d2877
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_SET\n", __func__);
2430,2431d2879
< 		{
< 			pr_err("MSMFB_OVERLAY_SET kmalloc result was NULL \n");
2433d2880
< 		}
2447d2893
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_UNSET\n", __func__);
2453d2898
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_PLAY_ENABLE\n", __func__);
2464d2908
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_PLAY\n", __func__);
2480d2923
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_PLAY_WAIT\n", __func__);
2496d2938
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_VSYNC_CTRL\n", __func__);
2498d2939
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_VSYNC_CTRL\n", __func__);
2500d2940
< 			mutex_lock(&mfd->ctx_lock);
2502d2941
< 			mutex_unlock(&mfd->ctx_lock);
2509d2947
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_OVERLAY_COMMIT\n", __func__);
2514d2951
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_METADATA_SET\n", __func__);
2521d2957
< 		ID_PRINTK(ID_HDMI, "%s() MSMFB_METADATA_GET\n", __func__);
2533d2968
< 		ID_PRINTK(ID_HDMI, "%s() default\n", __func__);
2602c3037
< 	struct mdss_panel_info *pinfo = mfd->panel_info;
---
> 	struct mdss_panel_info *pinfo;
2606a3042,3043
> 	pinfo = mfd->panel_info;
> 
2610d3046
< 	pr_info("%s: ++ \n",__func__);
2621a3058,3063
> 	rc = pm_runtime_get_sync(&mfd->pdev->dev);
> 	if (IS_ERR_VALUE(rc)) {
> 		pr_err("unable to resume with pm_runtime_get_sync rc=%d\n", rc);
> 		goto end;
> 	}
> 
2625c3067,3068
< 		!(pinfo->alpm_event && pinfo->alpm_event(CHECK_PREVIOUS_STATUS))) {
---
> 		!(pinfo->alpm_event &&
> 		pinfo->alpm_event(CHECK_PREVIOUS_STATUS))) {
2627c3070,3072
< 		if (!IS_ERR_VALUE(rc))
---
> 		if (rc)
> 			goto error_pm;
> 		if (mfd->panel_info->type != WRITEBACK_PANEL)
2632c3077
< 			return rc;
---
> 			goto error_pm;
2637a3083,3107
> 		goto end;
> 	}
> 
> error_pm:
> 	if (rc)
> 		pm_runtime_put_sync(&mfd->pdev->dev);
> end:
> 	return rc;
> }
> 
> static int mdss_mdp_overlay_disable_ulps(struct msm_fb_data_type *mfd)
> {
> 	struct mdss_overlay_private *mdp5_data;
> 
> 	if (!mfd)
> 		return -ENODEV;
> 
> 	if (mfd->key != MFD_KEY)
> 		return -EINVAL;
> 
> 	mdp5_data = mfd_to_mdp5_data(mfd);
> 
> 	if (!mdp5_data || !mdp5_data->ctl) {
> 		pr_err("ctl not initialized\n");
> 		return -ENODEV;
2640c3110,3141
< 	pr_info("%s: -- \n",__func__);
---
> 	if (!mdp5_data->ctl->power_on)
> 		return 0;
> 
> 	return mdss_mdp_ctl_disable_ulps(mdp5_data->ctl);
> }
> 
> static int mdss_mdp_overlay_off_pan_on(struct msm_fb_data_type *mfd)
> {
> 	int rc = 0;
> 	struct mdss_overlay_private *mdp5_data;
> 
> 	if (!mfd)
> 		return -ENODEV;
> 
> 	if (mfd->key != MFD_KEY)
> 		return -EINVAL;
> 
> 	mdp5_data = mfd_to_mdp5_data(mfd);
> 
> 	if (!mdp5_data || !mdp5_data->ctl) {
> 		pr_err("ctl not initialized\n");
> 		return -ENODEV;
> 	}
> 
> 	if (!mdp5_data->ctl->power_on)
> 		return 0;
> 
> 	rc = mdss_mdp_ctl_off_pan_on(mdp5_data->ctl);
> 	if (!rc) {
> 		pm_runtime_set_suspended(&mfd->pdev->dev);
> 		rc = mdss_mdp_cx_ctrl(mdp5_data->mdata, 0);
> 	}
2651c3152
< 	struct mdss_panel_info *pinfo;
---
> 	struct mdss_panel_info *pinfo = NULL;
2655a3157,3158
> 	pinfo = mfd->panel_info;
> 
2659,2660d3161
< 	pinfo = mfd->panel_info;
< 
2670a3172,3176
> 	if (mdp5_data->mdata->ulps) {
> 		mdss_mdp_footswitch_ctrl_ulps(1, &mfd->pdev->dev);
> 		mdss_mdp_ctl_restore(mdp5_data->ctl);
> 	}
> 
2686,2687c3192,3194
< 		if (pinfo->alpm_event && pinfo->alpm_event(CHECK_CURRENT_STATUS)) {
< 			pr_debug("[ALPM_DEBUG] %s, Skip cleanup pipes on fb%d\n",\
---
> 		if (pinfo->alpm_event &&
> 			pinfo->alpm_event(CHECK_CURRENT_STATUS)) {
> 			pr_debug("[ALPM_DEBUG] %s, Skip cleanup pipes on fb%d\n",
2720,2727c3227
< 	static int first_register=true;
< 	/*
< 	 * Clocks are already on if continuous splash is enabled,
< 	 * increasing ref_cnt to help balance clocks once done.
< 	 */
< 	if (pdata->panel_info.cont_splash_enabled && first_register) {
< 		pr_info("%s ++ \n", __func__);
< 		mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_ON, false);
---
> 	if (pdata->panel_info.cont_splash_enabled)
2729,2733c3229
< #ifdef CONFIG_FB_MSM_EDP_SAMSUNG
< 		mdss_mdp_clk_ctrl(MDP_BLOCK_POWER_OFF, false);
< #endif
< 		first_register=false;
< 	}
---
> 
2736a3233,3282
> static int __mdss_mdp_ctl_handoff(struct mdss_mdp_ctl *ctl,
> 	struct mdss_data_type *mdata)
> {
> 	int rc = 0;
> 	int i, j;
> 	u32 mixercfg;
> 	struct mdss_mdp_pipe *pipe = NULL;
> 
> 	if (!ctl || !mdata)
> 		return -EINVAL;
> 
> 	for (i = 0; i < mdata->nmixers_intf; i++) {
> 		mixercfg = mdss_mdp_ctl_read(ctl, MDSS_MDP_REG_CTL_LAYER(i));
> 		pr_debug("for lm%d mixercfg = 0x%09x\n", i, mixercfg);
> 
> 		j = MDSS_MDP_SSPP_VIG0;
> 		for (; j < MDSS_MDP_MAX_SSPP && mixercfg; j++) {
> 			u32 cfg = j * 3;
> 			if ((j == MDSS_MDP_SSPP_VIG3) ||
> 			    (j == MDSS_MDP_SSPP_RGB3)) {
> 				/* Add 2 to account for Cursor & Border bits */
> 				cfg += 2;
> 			}
> 			if (mixercfg & (0x7 << cfg)) {
> 				pr_debug("Pipe %d staged\n", j);
> 				pipe = mdss_mdp_pipe_search(mdata, BIT(j));
> 				if (!pipe) {
> 					pr_warn("Invalid pipe %d staged\n", j);
> 					continue;
> 				}
> 
> 				rc = mdss_mdp_pipe_handoff(pipe);
> 				if (rc) {
> 					pr_err("Failed to handoff pipe%d\n",
> 						pipe->num);
> 					goto exit;
> 				}
> 
> 				rc = mdss_mdp_mixer_handoff(ctl, i, pipe);
> 				if (rc) {
> 					pr_err("failed to handoff mix%d\n", i);
> 					goto exit;
> 				}
> 			}
> 		}
> 	}
> exit:
> 	return rc;
> }
> 
2752,2754d3297
< 	int i, j;
< 	u32 reg;
< 	struct mdss_mdp_pipe *pipe = NULL;
2755a3299
> 	struct mdss_mdp_ctl *sctl = NULL;
2766,2770d3309
< 	if (IS_ERR_OR_NULL(ctl)) {
< 		rc = PTR_ERR(ctl);
< 		goto error;
< 	}
< 
2776,2779c3315,3318
< 		if (rc) {
< 			pr_err("Failed to initialize ctl\n");
< 			goto error;
< 		}
---
> 	if (rc) {
> 		pr_err("Failed to initialize ctl\n");
> 		goto error;
> 	}
2784,2807c3323,3327
< 	for (i = 0; i < mdata->nmixers_intf; i++) {
< 		reg = mdss_mdp_ctl_read(ctl, MDSS_MDP_REG_CTL_LAYER(i));
< 		pr_debug("for lm%d reg = 0x%09x\n", i, reg);
< 		for (j = MDSS_MDP_SSPP_VIG0; j < MDSS_MDP_MAX_SSPP; j++) {
< 			u32 cfg = j * 3;
< 			if ((j == MDSS_MDP_SSPP_VIG3) ||
< 				(j == MDSS_MDP_SSPP_RGB3)) {
< 				/* Add 2 to account for Cursor & Border bits */
< 				cfg += 2;
< 			}
< 			if (reg & (0x7 << cfg)) {
< 				pr_debug("Pipe %d staged\n", j);
< 				pipe = mdss_mdp_pipe_search(mdata, BIT(j));
< 				if (!pipe) {
< 					pr_warn("Invalid pipe %d staged\n", j);
< 					continue;
< 				}
< 
< 				rc = mdss_mdp_pipe_handoff(pipe);
< 				if (rc) {
< 					pr_err("Failed to handoff pipe num %d\n"
< 						, pipe->num);
< 					goto error;
< 				}
---
> 	rc = __mdss_mdp_ctl_handoff(ctl, mdata);
> 	if (rc) {
> 		pr_err("primary ctl handoff failed. rc=%d\n", rc);
> 		goto error;
> 	}
2809,2815c3329,3339
< 				rc = mdss_mdp_mixer_handoff(ctl, i, pipe);
< 				if (rc) {
< 					pr_err("failed to handoff mixer num %d\n"
< 						, i);
< 					goto error;
< 				}
< 			}
---
> 	if (mfd->split_display) {
> 		sctl = mdss_mdp_get_split_ctl(ctl);
> 		if (!sctl) {
> 			pr_err("cannot get secondary ctl. fail the handoff\n");
> 			rc = -EPERM;
> 			goto error;
> 		}
> 		rc = __mdss_mdp_ctl_handoff(sctl, mdata);
> 		if (rc) {
> 			pr_err("secondary ctl handoff failed. rc=%d\n", rc);
> 			goto error;
2823,2825d3346
< #if defined(CONFIG_FB_MSM_MIPI_SAMSUNG_TFT_VIDEO_WQXGA_PT_PANEL)
< 	mdp5_data->handoff = false;
< #else
2827d3347
< #endif
2841a3362,3418
> static int mdss_mdp_overlay_splash_image(struct msm_fb_data_type *mfd,
> 						int *pipe_ndx, int splash_event)
> {
> 	struct mdp_overlay req;
> 	int rc = 0;
> 	struct fb_info *fbi = NULL;
> 	int image_len = 0;
> 
> 	if (!mfd || !mfd->fbi || !mfd->fbi->screen_base || !pipe_ndx) {
> 		pr_err("Invalid input parameter\n");
> 		return -EINVAL;
> 	}
> 
> 	fbi = mfd->fbi;
> 	image_len = SPLASH_IMAGE_WIDTH * SPLASH_IMAGE_HEIGHT * SPLASH_IMAGE_BPP;
> 
> 	if (SPLASH_IMAGE_WIDTH > fbi->var.xres ||
> 			SPLASH_IMAGE_HEIGHT > fbi->var.yres ||
> 			SPLASH_IMAGE_BPP > fbi->var.bits_per_pixel / 8 ||
> 			image_len > fbi->fix.smem_len) {
> 		pr_err("Invalid splash parameter configuration\n");
> 		return -EINVAL;
> 	}
> 
> 	if (splash_event == MDP_CREATE_SPLASH_OV) {
> 		pipe_ndx[0] = INVALID_PIPE_INDEX;
> 		pipe_ndx[1] = INVALID_PIPE_INDEX;
> 
> 		memset(&req, 0, sizeof(struct mdp_overlay));
> 		req.src.width = req.dst_rect.w = req.src_rect.w =
> 				SPLASH_IMAGE_WIDTH;
> 		req.src.height = req.dst_rect.h = req.src_rect.h =
> 				SPLASH_IMAGE_HEIGHT;
> 		req.src.format = SPLASH_IMAGE_FORMAT;
> 		req.id = MSMFB_NEW_REQUEST;
> 		req.z_order = MDSS_MDP_STAGE_0;
> 		req.is_fg = 1;
> 		req.alpha = 0xff;
> 		req.transp_mask = MDP_TRANSP_NOP;
> 		req.dst_rect.x =
> 			(fbi->var.xres >> 1) - (SPLASH_IMAGE_WIDTH >> 1);
> 		req.dst_rect.y =
> 			(fbi->var.yres >> 1) - (SPLASH_IMAGE_HEIGHT >> 1);
> 
> 		memcpy(fbi->screen_base, splash_bgr888_image, image_len);
> 		mdss_mdp_overlay_pan_display(mfd, &req, image_len, pipe_ndx);
> 
> 	} else if (splash_event == MDP_REMOVE_SPLASH_OV) {
> 		if (pipe_ndx[0] != INVALID_PIPE_INDEX)
> 			mdss_mdp_overlay_unset(mfd, pipe_ndx[0]);
> 		if (pipe_ndx[1] != INVALID_PIPE_INDEX)
> 			mdss_mdp_overlay_unset(mfd, pipe_ndx[1]);
> 	}
> 
> 	return rc;
> }
> 
2951a3529,3530
> 	mdp5_interface->off_pan_on_fnc = mdss_mdp_overlay_off_pan_on;
> 	mdp5_interface->disable_ulps = mdss_mdp_overlay_disable_ulps;
2959a3539
> 	mdp5_interface->splash_fnc = mdss_mdp_overlay_splash_image;
2982d3561
< 	mfd->wait_for_kickoff = true;
3001a3581,3590
> 	rc = sysfs_create_link_nowarn(&dev->kobj,
> 			&mdp5_data->mdata->pdev->dev.kobj, "mdp");
> 	if (rc)
> 		pr_warn("problem creating link to mdp sysfs\n");
> 
> 	rc = sysfs_create_link_nowarn(&dev->kobj,
> 			&mfd->pdev->dev.kobj, "mdss_fb");
> 	if (rc)
> 		pr_warn("problem creating link to mdss_fb sysfs\n");
> 
3017,3020d3605
< 	rc = sysfs_create_link_nowarn(&dev->kobj,
< 			&mdp5_data->mdata->pdev->dev.kobj, "mdp");
< 	if (rc)
< 		pr_warn("problem creating link to mdp sysfs\n");
3063c3648
< 		pr_info("mem reservation for splash screen fb not present\n");
---
> 		pr_debug("mem reservation for splash screen fb not present\n");
3073c3658
< 		pr_info("Error reading mem reserve settings for fb\n");
---
> 		pr_debug("Error reading mem reserve settings for fb\n");
3078c3663
< 		pr_info("failed to reserve memory for fb splash\n");
---
> 		pr_debug("failed to reserve memory for fb splash\n");
3085c3670
< 	pr_info("memaddr=%x size=%x\n", mdp5_mdata->splash_mem_addr,
---
> 	pr_debug("memaddr=%x size=%x\n", mdp5_mdata->splash_mem_addr,
3115,3171d3699
< 
< #if defined (CONFIG_FB_MSM_MDSS_DBG_SEQ_TICK)
< void mdss_dbg_tick_save(int op_name)
< {
< 	ktime_t tick;
< 	tick = ktime_get();
< 
< 	switch(op_name)
< 	{
< 		case COMMIT :
< 			mdss_dbg_tick.commit[mdss_dbg_tick.commit_cnt] = ktime_to_ns(tick);
< 			mdss_dbg_tick.commit_cnt++;
< 			if(mdss_dbg_tick.commit_cnt > 9)
< 				mdss_dbg_tick.commit_cnt = 0;
< 			break;
< 		case KICKOFF :
< 			mdss_dbg_tick.kickoff[mdss_dbg_tick.kickoff_cnt] = ktime_to_ns(tick);
< 			mdss_dbg_tick.kickoff_cnt++;
< 			if(mdss_dbg_tick.kickoff_cnt > 9)
< 				mdss_dbg_tick.kickoff_cnt = 0;
< 			break;
< 		case PP_DONE :
< 			mdss_dbg_tick.pingpong_done[mdss_dbg_tick.pingpong_done_cnt] = ktime_to_ns(tick);
< 			mdss_dbg_tick.pingpong_done_cnt++;
< 			if(mdss_dbg_tick.pingpong_done_cnt > 9)
< 				mdss_dbg_tick.pingpong_done_cnt = 0;
< 			break;
< 	}
< }
< 
< #endif
< /*
<  * [srcx,srcy,srcw,srch]->[dstx,dsty,dstw,dsth][flags]|src_format|bpp|pipe_ndx|
<  * mdp_clk = %ld, bus_ab = %llu, bus_ib = %llu
<  */
< void mdss_mdp_underrun_dump_info(struct msm_fb_data_type *mfd)
< {
< 	struct mdss_mdp_pipe *pipe;
< 	struct mdss_overlay_private *mdp5_data = mfd_to_mdp5_data(mfd);
< 
< 	pr_info(" ============ dump_start ===========\n");
< 	
< 	list_for_each_entry(pipe, &mdp5_data->pipes_used, used_list) {
< 		if (pipe)
< 			pr_info(" [%4d, %4d, %4d, %4d] -> [%4d, %4d, %4d, %4d]"
< 					"|flags = %8d|src_format = %2d|bpp = %2d|ndx = %3d|\n",
< 			pipe->src.x, pipe->src.y, pipe->src.w, pipe->src.h,
< 			pipe->dst.x, pipe->dst.y, pipe->dst.w, pipe->dst.h,
< 			pipe->flags, pipe->src_fmt->format, pipe->src_fmt->bpp,
< 			pipe->ndx);
< 		pr_info("pipe addr : %p\n", pipe);
< 	}
< 
< 	mdss_mdp_underrun_clk_info();
< 	pr_info(" ============ dump_end =========== \n");
< }
< 
